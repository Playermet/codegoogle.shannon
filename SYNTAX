
#
# BNF for Shannon:
#   repeat 0 or more times: {...}
#   optional: [...]
#   group: (...)
#   OR: |
#   literal: "..." or '...'
#   any word: reference to another syntactic element
#   glue: ## (otherwise elements are separated by whitespace or can be 
#       distinguished by the parser)
#   end of statement: <SEP> (end-of-line or ';')
#   block-begin and block-end: <BEGIN> and <END> (':' followed by indented
#       blocks until unindent to the previous level, or a special case with
#       a single line that follows after ':', also C-style blocks will be
#       supported in the future
#


# Basic elements

ident ::= ( letter | "_" ) ## { letter | digit | "_" }

decimal ::= digit ## { digit }

hexadecimal ::= '0x' ## hexdigit ## { hexdigit }

string-literal ::= "'" ## { string-element } ## "'"

string-element ::= printable-char | string-escape

string-escape ::= "\\" | "\t" | "\r" | "\n" | "\'"
        | ( "\x" ## hexdigit ## hexdigit )


# Expressions

expr ::= rel-expr [ '..' rel-expr ]

rel-expr ::= simple-expr { ( '==' | '<' | '<=' | '>=' | '>' | '!=' ) simple-expr }

simple-expr ::= term { ( '+' | '-' | 'or' | 'xor' ) term }

term ::= factor { ( '*' | '/' | 'mod' | 'and' | 'shl' | 'shr' ) factor }

factor ::= [ '-' | 'not' ] designator

designator ::= atom { }

atom ::= literal | qualified-name | subexpr | compound-ctor
    | fifo-ctor | type

literal ::= number | string | "true" | "false" | "null"

qualified-name ::= { ident "." } ident

subexpr ::= "(" expr ")"



compound-ctor ::= "[" [ element-ctor { "," element-ctor } ] "]"

element-ctor ::= [ expr "=" ] expr

fifo-ctor ::= "<" [ expr-list ] ">"

expr-list ::= expr { "," expr }

array-item-selection ::= "[" expr "]"

fifo-item-selection ::= "<" ">"

function-call ::= "(" [ expr-list ] ")"

mute ::= "^"

fifo-pull ::= atom "::" expr

fifo-filter ::= atom "||" expr

subrange ::= rel-expr ".." rel-expr


# Module

module ::= [module-header] { statement | definition }

module-header ::= "module" ident

statement ::= call | pipe | assignment | compount-statement


# Definitions

definition ::= type-def | const-def | var-def

type-def ::= type-alias | function-def

type-alias ::= "def" type ident { type-derivator }

type ::= type-id { type-derivator }

type-id ::= qualified-name | "typeof" "(" expr ")" | subrange | "enum"

type-derivator ::= array-derivator | mute-derivator | range-derivator
        | enum-spec

array-derivator ::= "[" [ type ] "]"

mute-derivator ::= "^"

range-derivator ::= "[" ".." "]"

enum-spec ::= "(" ident { "," ident ")"

function-def ::= "def" ( "state" | type | pipe-type ) [ arg-list ] [ function-body ]

pipe-type ::= type "/" type

const-def ::= "const" ( auto-object-spec | typed-object-spec ) "=" const-expr

var-def ::= "var" ( auto-object-spec | typed-object-spec ) "=" expr

auto-object-spec ::= ident

typed-object-spec ::= type ident { type-derivator }

