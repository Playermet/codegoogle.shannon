
#
# BNF for Shannon:
#   repeat 0 or more times: {...}
#   optional: [...]
#   group: (...)
#   OR: |
#   literal: "..." or '...'
#   any word: reference to another syntactic element
#   glue: ## (otherwise elements are separated by whitespace or can be 
#       distinguished by the parser)
#   <SEP> is one or more new lines and/or semicolons
#   Comments are like in C++ /* */ and //
#


# ---------- Statements

program ::= { statement } <EOF>

statement ::= definition | var-def | sub-block | builtin | other-statement |
     if-block | case-block | while-block | 'break' | 'continue' | del

block ::= single-block | multi-block

single-block ::= [ <SEP> ] statement

multi-block ::= '{' [ <SEP> ] { statement } '}' 

definition ::= 'def' [ const-expr ] ident { type-derivator } '=' const-expr <SEP>

var-def ::= 'var' [ const-expr ] ident { type-derivator } '=' expr <SEP>

sub-block ::= 'begin' block

builtin ::= assertion | dump | exit

assertion ::= 'assert' expr <SEP>

dump ::= 'dump' expr { ',' expr } <SEP>

exit ::= 'exit' expr <SEP>

other-statement ::= designator [ '=' expr ] <SEP>

if-block ::= 'if' expr block { 'elif' expr block } [ 'else' block ]

case-block ::= 'case' expr '{' case-label { case-label } '}'

case-label ::= expr [ '..' expr ] ':' block

while-block ::= 'while' expr block

del ::= 'del' designator


# ---------- Const Expression

const-expr ::= subrange-type | enum-type | type-spec | expr

subrange-type ::= expr '..' expr

enum-type ::= ident { ',' ident }


# ---------- Expression

expr ::= and-level { ( 'or | 'xor' ) and-level }

and-level ::= not-level { ( 'and' | 'shl' | 'shr' ) not-level }

not-level ::= [ 'not' ] relation

relation ::= arithm-expr [ 'in' in-expr |
    ( '==' | '<>' | '<' | '<=' | '>' | '>=' ) arithm-expr ]

in-expr ::= arithm-expr [ '..' arithm-expr ]

arithm-expr ::= term { ( '+' | '-' ) term }

term ::= cat-expr { ( '*' | '/' | '%' ) cat-expr }

cat-expr ::= factor { '|' factor }

factor ::= [ '-' ] [ '?' ] [ '#' ] designator [ ( 'as' | 'is' ) designator ]

designator ::= [ '@' ] atom { '^' | '.' ident | '[' index-expr ']' }

atom ::= ident | number | string-literal | vec-ctor | dict-ctor | if-func |
    typeof | type-spec | '(' expr ')'

vec-ctor ::= '[' [ expr { ',' expr } ] ']'

dict-ctor ::= '{' [ dict-elem { ',' dict-elem } ] '}'

dict-elem ::= expr [ '=' expr ]

if-func ::= 'if' '(' expr ',' expr ',' expr ')'

typeof ::= 'typeof' designator

type-spec ::= ident '*' type-derivator { type-derivator }

type-derivator ::= ( '[' [ const-expr ] ']' ) | '<>'

index-expr ::= expr [ '..' [ expr ] ]


# ---------- Basic elements

ident ::= ( letter | "_" ) ## { letter | digit | "_" }

number ::= decimal | hexadecimal

decimal ::= digit ## { digit }

hexadecimal ::= "0x" ## hexdigit ## { hexdigit }

string-literal ::= "'" ## { string-element } ## "'"

string-element ::= printable-char | string-escape

string-escape ::= "\\" | "\t" | "\r" | "\n" | "\'"
        | ( "\x" ## hexdigit ## hexdigit )

