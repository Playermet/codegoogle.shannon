
#
# BNF for Shannon:
#   repeat 0 or more times: {...}
#   optional: [...]
#   group: (...)
#   OR: |
#   literal: "..." or '...'
#   any word: reference to another syntactic element
#   glue: ## (otherwise elements are separated by whitespace or can be 
#       distinguished by the parser)
#   end of statement: <SEP> (end-of-line or ';')
#   block-begin and block-end: <BEGIN> and <END> (':' followed by indented
#       blocks until unindent to the previous level, or a special case with
#       a single line that follows after ':', also C-style blocks are 
#       supported.
#


module ::= statement-list

# ---------- Statements

statement-list ::= { ( definition | statement ) <SEP> }

definition ::= 'def' [ type-expr ] ident { type-derivator } '=' ( expr | type-expr )

statement ::= call | pipe | assignment | compound-statement | if-clause
    | while-clause | "break" | "continue" | case-clause | "return"
    | var-def

var-def ::= 'var' [ type-expr ] ident { type-derivator } '=' expr

assignment ::= designator "=" expr

compound-statement ::= "begin" block

block ::= <BEGIN> statement-list <END>

if-clause ::= "if" expr <BEGIN> statement-list
        { <END> "elif" <BEGIN> statement-list }
        [ <END> "else" <BEGIN> statement-list ]
        <END>

while-clause ::= "while" expr block

case-clause ::= "case" expr <BEGIN>
        { case-label { "," case-label } block }
        [ "else" block ]
        <END>

case-label ::= const-expr | subrange


# ---------- Expressions

type-expr ::= factor [ ".." factor ]

expr ::= and-expr { ( "or" | "xor" ) and-expr }

and-expr ::= not-expr { ( "and" | "shl" | "shr" ) not-expr }

not-expr ::= [ "not" ] rel-expr

rel-expr ::= ( simple-expr { ( "==" | "<" | "<=" | ">=" | ">" | "!=" | "<>" ) simple-expr } )
    | ( simple-expr "in" simple-expr [ ".." simple-expr ] )

simple-expr ::= arithm-expr { "|" arithm-expr }

arithm-expr ::= term { ( "+" | "-" ) term }

term ::= factor { ( "*" | "/" | "mod" ) factor }

factor ::= [ "-" ] designator [ '*' { type-derivator } ]

designator ::= atom { array-item-selection | member-selection | function-call }

atom ::= number | string | ident | subexpr | compound-ctor

type-derivator ::= array-derivator | fifo-derivator | function-derivator

subexpr ::= "(" expr ")"

compound-ctor ::= "[" [ element-ctor { "," element-ctor } "]"

element-ctor ::= [ expr ( "=" | ".." ) ] expr

if-expr ::= "if" "(" expr, expr, expr ")"

array-item-selection ::= "[" expr "]"

member-selection ::= '.' ident

function-call ::= "(" [ expr-list ] ")"

expr-list ::= expr { "," expr }


# Basic elements

ident ::= ( letter | "_" ) ## { letter | digit | "_" }

number ::= decimal | hexadecimal

decimal ::= digit ## { digit }

hexadecimal ::= "0x" ## hexdigit ## { hexdigit }

string-literal ::= "'" ## { string-element } ## "'"

string-element ::= printable-char | string-escape

string-escape ::= "\\" | "\t" | "\r" | "\n" | "\'"
        | ( "\x" ## hexdigit ## hexdigit )

