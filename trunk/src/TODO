
* Assignment operators (+=, etc) aren't very nice with the
  boolean/bitwise and, or, etc. However, these are necessary at least:
  |=, +=, -=, also append operator in the form v[] = ...

* Operator 'ins' for all types of containers.

* for loop: allow types, also range as an exception can have variable  
  boundaries. E.g. for i = a ... Iterators for all container types.
  Iterators should lock the container to prevent modification.

* Functions: function pointers, indirect calls, 'this', method calls

* return, goto

* Tiny set implementation? Maybe

* Builtins are defined within states; "global" builtins are in QueenBee.
  How about containers?

* A state name is a type that describes a state, not a prototype. Now,
  what to do with prototypes and function addresses?

* Nullable types: var ?int i = v as int(0)  (better syntax needed) Any 
  operation returns null if any one of the operands is null. (Or maybe
  var ?int i = v as int else 0). Oh man, it's patented! Any ideas?

* Read-only variables (const) and const subexpressions? A bit problematic:
  const should be part of type, not var definition.

* 'public' and 'forward' blocks: can contain a single statement after ':' or
  multiple statements in { }.

* Small ordinals with the 's' prefix? Custom prefixes will be used for
  measurement units as well, don't know.

* finally { ... } is a nested block which is executed if the enclosing
  block reaches its end, i.e. the finally label. For states this is the
  destructor. Not the same as try ... finally construct.

* "def self ..." is not nice, maybe "class ..." is better, or "state"

* Structs are almost like vectors, except element types are specified    
  individually. Can be used for returning multiple values from functions.    
  So a struct descriptor is a vector of types?

* Enqueue and dequeue operators: << and >>, like the iostream operators
  in C++. The leftmost operand is always a fifo. (Precedence compared to
  the pipe operator "||" ?)

* Procedures are declared as, e.g. def char||char convert() ...

* A special return value with 'var' indicates it's a special method
  that's called on a variable or a reference, e.g. def (var chars)
  include(int, ... Might be especially useful for builtins.

* Operator 'split': a combination of 'case' and 'while' for fifos (?)

* Ordinal set operations: inversion (not), union (or), intersection
  (and), subtraction (-)

* Exceptions

* Run-time range checking (as well as compile-time)

* HTML/XML embedded mode, also arbitrary text embedded mode

* Compiler directives: DEBUG ON|OFF  RANGE_CHECK ON|OFF  ASSERT ON|OFF
  ECHO ON|OFF  MARKUP ON|OFF (syntax?)

* Two versions of the binary: debug and release. Debug helps to debug
  both the program (assertions, dumps and range checking are on) and the
  compiler itself

* Abstract module and module inheritance paradigm. Modules can be loaded
  at run time, but they should be inherited from some known module type.
  Database drivers can be written this way.

* Alternate syntax for string keys in dictionaries: dict->key. This will
  work for dynamic states too (?).

* Have the code generator evaluate some operations at generation time if  
  possible.

* Floating point type

* Multidimensional arrays implemented as a single vector with "flat"
  indexing?

* A lot of TODO's in the source

