
* When function/state is used as a type, take the return type

* Functions: function pointers, indirect calls, method calls

* Builtins are defined within states; "global" builtins are in QueenBee.
  What about containers? Fifos?

* Enqueue and dequeue operators: << and >>, almost like the iostream
  operators in C++. The leftmost operand is always a fifo.

* return, goto

* Prototypes are distinguished from function defs by trailing '...'

* Operator 'in' for vectors? 'lin'?

* So what keyword: 'class' or 'state'? Or none?

* Procedures, pipes. Procedures are declared as, e.g. def <char, char>
  convert() ...

* Exceptions

* Anonymous functions

* Properties

* Tiny set implementation?

* Alternate syntax for string keys in dictionaries: dict->key. This will
  work for dynamic states too (?). Also, the ability to iterate over all
  state members with the 'for' operator - how?

* Nullable types: patented by Microsoft. Instead, maybe just use 'any'
  and operator '?', e.g. v = v ? 0 (if null then assign 0)

* Read-only variables (const) and const subexpressions? A bit problematic:
  const should be part of type, not var definition.

* 'public' and 'forward' blocks

* Small ordinals with the 's' prefix? Custom prefixes will be used for
  measurement units as well, don't know.

* finally { ... } is a nested block which is executed if the enclosing
  block reaches its end, i.e. the finally label. For states this is the
  destructor. Not the same as try ... finally construct.

* Structs are almost like vectors, except element types are specified    
  individually. Can be used for returning multiple values from functions.    
  So a struct descriptor is a vector of types?

* A special return value with 'var' indicates it's a special method
  that's called on a variable or a reference, e.g. def (var chars)
  include(int, ... Might be especially useful for builtins.

* Operator 'split': a combination of 'case' and 'while' for fifos (?)

* Ordinal set operations: inversion (not), union (or), intersection
  (and), subtraction (-)

* Run-time range checking (as well as compile-time)

* HTML/XML embedded mode, also arbitrary text embedded mode

* Compiler directives: DEBUG ON|OFF  RANGE_CHECK ON|OFF  ASSERT ON|OFF
  ECHO ON|OFF  MARKUP ON|OFF (syntax?)

* Two versions of the binary: debug and release. Debug helps to debug
  both the program (assertions, dumps and range checking are on) and the
  compiler itself

* Abstract module and module inheritance paradigm. Modules can be loaded
  at run time, but they should be inherited from some known module type.
  Database drivers can be written this way.

* Have the code generator evaluate some operations at generation time if  
  possible.

* Floating point type

* Default function parameters, named arguments

* Multidimensional arrays implemented as a single vector with "flat"
  indexing?

* Assignment operators (+=, etc) aren't very nice with the
  boolean/bitwise and, or, etc. However, these are necessary at least:
  |=, +=, -=, *=, /=, %=

* A lot of TODO's in the source

