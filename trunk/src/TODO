
* $ is for run-time symbols (keyword-like string literals) (?)

* Vector constructor is enclosed in < > and is compatible with fifos. A single 
  element can be automatically converted to a vector when necessary. Same for 
  char/str, since char is not distinguishable from string syntactically anyway.
  The angle brackets play well with the fifo derivator <>, since fifo literals
  are vectors.

* Dicts and sets are declared as "elem-type name[index-type]". For sets the
  element type is "none". Operator "in" is applicable to both dicts and sets.
  Dict/set constructors are in square brackets.

* Operator 'delete' for removing container elements. 

* Fifos are defined as "elem-type name<>"

* finally { ... } is a nested block which is executed if the enclosing block
  reaches its end, i.e. the finally label. For states this is the destructor.
  Not the same as try ... finally construct.

* A code block in an expression is an anonymous function; the exact type is
  determined by the target. Build the execution context for an anon function
  (copy all external values into a temp object?)

* "def self ..." is not nice, maybe "class ..." is better, or "state"

* Tuples are almost like vectors, except element types are specified
  individually. Can be used for returning multiple values from functions.

* Enqueue and dequeue operators: << and >>, like the iostream operators in C++.
  The leftmost operand is always a fifo. (Precedence compared to the pipe
  operator "||" ?)

* All values except states are immutable unless declared as references with the
  ^ type derivator. Operation ^ (prefix) makes a value a reference. Dereference
  in expressions is automatic. A reference internally is represented as a 
  pointer to an object and an offset inside it.

* Range (e.g. A..B) is possible only: (1) in const type expressions where it
  denotes a range type, (2) in ordinal set constructors, (3) in operator 'for',
  (4) with operator 'in'

* Operator 'split': a combination of 'case' and 'while' for fifos (?)

* Operators 'is' and 'as'

* if, while, case

* Ordinal set operations: inversion (not), union (or), intersection (and),
  subtraction (-)

* Iterators for all container types. Iterators should lock the container to
  prevent modification.

* A `pair` data type, which is a dictionary iteration element. But maybe not
  only. Can be a built-in state with two fields (?)

* for loop: allow types, also range as an exception can have variable
  boundaries. E.g. for i = a ...

* Functions

* Run-time range checking (as well as compile-time)

* Nullable types? Look at C#. Easy to implement, just need strictly defined
  semantics, also a default assignment operator, again, like in C#.

* HTML/XML embedded mode, also arbitrary text embedded mode

* Compiler directives: DEBUG ON|OFF  RANGE_CHECK ON|OFF  ASSERT ON|OFF
  ECHO ON|OFF  MARKUP ON|OFF (syntax?)

* Two versions of the binary: debug and release. Debug helps to debug both the
  program (assertions, dumps and range checking are on) and the compiler itself

* Abstract module and module inheritance paradigm. Modules can be loaded at run
  time, but they should be inherited from some known module type. Database
  drivers can be written this way.

* Alternate syntax for string keys in dictionaries: dict->key. This will work
  for dynamic states too (?). Actually dict.key might work too.

* Forward declarations

* Have the code generator evaluate some operations at generation time if
  possible. Need to store codeseg offset with each genstack element.

* Built-ins: empty(), count() etc.

* Assignment operators (+=, etc) aren't very nice with the boolean/bitwise
  and, or, etc.

