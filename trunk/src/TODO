
* Drop Python-like syntax. Comments are C++-style. # is for directives. $ is
  for run-time symbols (keyword-like string literals).

* Set constructors use <>. Set type is defined as, e.g. char myset<>. Operator
  <> tests presence of an item in a set or a key in a map. Set delete and add
  operations? "unset" maybe?
  
* Fifos are defined as char myfifo[..] (?)

* Enqueue and dequeue operators: << and >>, like the iostream operators in C++

* All values except states are immutable unless declared as references with the
  ^ type derivator. Operation ^ (prefix) makes a value a reference. Dereference
  in expressions is automatic.

* Operator 'split': a combination of 'case' and 'while' for fifos (?)

* Operators 'is' and 'as'

* if, while, case

* Ordinal set operations: inversion (not), union (or), intersection (and),
  subtraction (-)

* Iterators for all container types. Iterators should lock the container to
  prevent modification.

* A `pair` data type, which is a dictionary iteration element. But maybe not
  only. Can be a built-in state with two fields (?)

* for loop: allow types, also range as an exception can have variable
  boundaries. E.g. for i = a ...

* Functions

* Run-time range checking (as well as compile-time)

* Nullable types? Look at C#. Easy to implement, just need strictly defined
  semantics, also a default assignment operator, again, like in C#.

* Range types and ordinal sets should be mutually convertible

* Can vectors be converted or wrapped in fifos? Implicitly or explicitly?

* Composite return values?

* Optimize function calls: if "self" is not used, define all local vars as
  just locals, not "this" vars. Actually this means if a function doesn't
  return "self", it can't use the self reference in any way. This is probably
  okay.

* HTML embedded mode

* Compiler directives: DEBUG ON|OFF  RANGE_CHECK ON|OFF  ASSERT ON|OFF
  ECHO ON|OFF  MARKUP ON|OFF (syntax?)

* := assignment as a function?

* Abstract module and module inheritance paradigm. Modules can be loaded at run
  time, but they should be inherited from some known module type. Database
  drivers can be written this way.

* Alternate syntax for string keys in dictionaries: dict->key. This will work
  for dynamic states too (?). Actually dict.key might work too.

* Forward declarations

* Have the code generator evaluate some operations at generation time if
  possible. Need to store codeseg offset with each genstack element.

* Built-ins: empty(), count() etc.

* Assignment operators (+=, etc) aren't very nice with the boolean/bitwise
  and, or, etc.

