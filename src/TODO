
* Operator 'in'

* Read-only variables (const) and const subexpressions.

* if, while, case, break, continue, goto, exit, return

* Operators 'ins' and 'del' (and 'swap'?) that work on containers.

* ByteByte dictionary implementation (small ordinal keys and values) -
  useful for char translation, but not absolutely necessary.

* Tiny set implementation?

* Multidimensional arrays implemented as a single vector with "clever"
  indexing?

* Builtins are defined within states; "global" builtins are in QueenBee.
  How about containers?

* Substring/subvector using '..' e.g.: s[1..3] or s[4..]

* A state name is a type that describes a state, not a prototype. Now,
  what to do with prototypes and function addresses?

* Nullable types: var ?int i = v as int(0)  (better syntax needed) Any 
  operation returns null if any one of the operands is null. (Or maybe
  var ?int i = v as int else 0). Oh man, it's patented! Any ideas?

* 'public' and 'forward' blocks: can contain a single statement after ':' or
  multiple statements in { }.

* Small ordinals with the 's' prefix? Custom prefixes will be used for
  measurement units as well, don't know.

* finally { ... } is a nested block which is executed if the enclosing
  block reaches its end, i.e. the finally label. For states this is the
  destructor. Not the same as try ... finally construct.

* "def self ..." is not nice, maybe "class ..." is better, or "state"

* Tuples are almost like vectors, except element types are specified    
  individually. Can be used for returning multiple values from functions.    
  So a tuple descriptor is a vector of types?

* Enqueue and dequeue operators: << and >>, like the iostream operators
  in C++. The leftmost operand is always a fifo. (Precedence compared to
  the pipe operator "||" ?)

* Procedures are declared as, e.g. def (pipe char, char) convert() ...

* A special return value with 'var' indicates it's a special method
  that's called on a variable or a reference, e.g. def (var chars)
  include(int, ... Might be especially useful for builtins.

* Range (e.g. A..B) is possible only: (1) in const type expressions
  where it denotes a range type, (2) in ordinal set constructors, (3) in
  operator 'for', (4) with operator 'in'

* Operator 'split': a combination of 'case' and 'while' for fifos (?)

* Ordinal set operations: inversion (not), union (or), intersection
  (and), subtraction (-)

* Iterators for all container types. Iterators should lock the container
  to prevent modification.

* A `pair` data type, which is a dictionary iteration element. But maybe   
  not only. Can be a built-in state with two fields (?)

* for loop: allow types, also range as an exception can have variable  
  boundaries. E.g. for i = a ...

* Functions

* Run-time range checking (as well as compile-time)

* HTML/XML embedded mode, also arbitrary text embedded mode

* Compiler directives: DEBUG ON|OFF  RANGE_CHECK ON|OFF  ASSERT ON|OFF
  ECHO ON|OFF  MARKUP ON|OFF (syntax?)

* Two versions of the binary: debug and release. Debug helps to debug
  both the program (assertions, dumps and range checking are on) and the
  compiler itself

* Abstract module and module inheritance paradigm. Modules can be loaded
  at run time, but they should be inherited from some known module type.
  Database drivers can be written this way.

* Alternate syntax for string keys in dictionaries: dict->key. This will
  work for dynamic states too (?).

* Have the code generator evaluate some operations at generation time if  
  possible. Need to store codeseg offset with each genstack element.

* Assignment operators (+=, etc) aren't very nice with the
  boolean/bitwise and, or, etc. However, these are necessary at least:
  |=, +=, -=

* A lot of TODO's in the source

