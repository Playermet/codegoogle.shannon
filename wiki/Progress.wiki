#summary Very brief description of language features as they are implemented already

*Syntax* is Python-style, however you can have C-style blocks, too. Once a curly bracket is opened, only curly brackets are possible inside. C-style blocks must always be enclosed with braces, even if they consist of one statement. When embedded in HTML the parser starts in curly-bracket mode, otherwise - in indent mode. In both cases ';' is optional and works as a placeholder for a new line. Use '\' to glue lines.

*Constant and variable declarations* start with const and var respectively (e.g. const int c = 0). Type specification can be omitted, in which case it is automatically determined from the initializer (var v = 0). Initializers are always required both for constants and variables.

*Type aliases* start with def, the rest is like in C, but also Java/C#-like syntax allowed. Or both. For example, int[] a[] is equivalent to int a[][] or int[][] a. Function/state definitions also start with def because they are types. Types are equivalent to constants of type typeref, so def int a[] is fully equivalent to const typeref a = int[], where typeref can be omitted, i.e. const a = int[].

*Ordinal subrange* type is similar to that of Pascal: you can have, for example, 0..9, 'a'..'z', Mon..Fri (if Mon and Fri are enum constants), etc. as type specs. In fact, int, char and bool are not built-in types, they are defined through subranges in the System module.

*Range type* is declared as type ident[..], where type must be ordinal. A value of type range is a pair of ordinals - int, char, or any enum. Range literals are in the form: e.g. 0..9, 'a'..'z' - not to be confused with the ordinal subrange type, which is a data type, not a value, although both look identical. Ranges are used in the loop operator, also you can write, for example: if c in '0'..'9' etc.

*Enum type* is declared as def enum ident(value1, value2, ...). Enums are not compatible with ints but can be statically typecasted. Enums or enum subranges can be used as array indexes.

*Arithmetic operators* are: +, -, `*`, /, mod, also bitwise and, or, xor, shl, shr, not. Boolean operators are: and, or, xor, not and are distinguished by operand types. In case of ambiguity boolean operators are assumed. Floating point type is not supported in the current version.

*Strings and vectors* are unified: concatenation (the pipe sign "|") and assignment rules apply to both, i.e. an element can be assigned or concatenated to a vector of a corresponding type. Strings have one additional feature though: they can be compared (==, <, <=, >=, !=), while vectors can only be compared for equality. The vector constructor ([a, b, ...]) can be used both in constant expressions and at run time.

*Arrays, dictionaries and sets*. Arrays and dictionaries are declared as elem-type ident[index-type]. The compiler determines automatically whether the type should be an array or a dictionary: the rule is that if the index type is ordinal with a small subrange (e.g. char, or 0..9), then it's an array with fixed length, in all othre cases the compiler generates a dynamic associative array, i.e. dictionary. Functionally, arrays and dictionaries are equivalent. One special case is when the element type is "none" (equivalent to void in C), which means a dictionary only has keys but not elements - that's a set. Sets with small ordinal ranges are optimized and kept as compact bit maps, while in all other cases internally sets are represented as search trees. Both dictionary keys and set elements are kept in sorted order.

*Set/array/dict literals* have same syntax [value, ...] or [key = value, ...]. The exact type is determined by the context. In cases where the type can't be determined, a typecast is required, e.g. when initializing a variant variable. A set literal is a list of keys with no values. For sets of ordinal types also ranges are allowed in value specs, e.g. [0..2, 5].

*Built-ins*: echo and assert are for debugging purposes: you can turn them off from the command line, in which case the compiler will ignore echo and assertion statements.

*The if() function* -- if (cond, a, b) -- is similar to the ?: operator in C. It accepts 3 arguments - the condition and 2 "branches", however, it executes only one of the branches, like the 'real' if statement, which is important to remember when using expressions with side effects.

*The begin block* is useful when defining block-local variables (and there is no "end", since the end of block is determined either by indentation in "Python mode" or by curly brackets).

*if... elif... else, while... break... continue...* Enjoy them. You don't need to put parens around  conditional expressions like in C.

*Case operator* is like in Pascal: the labels are constant values or ranges, also a list of values/ranges is allowed. In the current implementation, ordinals, typerefs and strings are allowed for case.

*Variant type* is called "any". It can hold any value, simple or compound, and also the value of a variant can be null. Variants should be typecast'ed explicitly in expressions and assignments mixed with typed entities. The only two automatic conversions possible are: to boolean in boolean expressions and also to a string in the echo statement. In fact, this applies to all types, not only variants.